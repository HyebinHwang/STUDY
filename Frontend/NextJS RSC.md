### How are Server Component Rendered?

1. 리액트는 React Server Component Payload(RSC payload)로 불리는 데이터 포멧 형태로 서버컴포넌트를 렌더합니다.
2. NextJS는 서버에서 RSC Payload와 Client Component를 자바스크립트 명령어를 사용해서 HTML를 렌더합니다.
Then on the Client:
3. HTML은 경로의 non-interactive한 미리보기에 즉시 사용됩니다. - 이는 초기 페이지 로드에만 사용됩니다.
4. RSC Payload는 클라이언트와 서버 컴포넌트 트리를 조정(reconcile)하고, DOM을 업데이트하는데 사용된다.
5. 자바스크립트 명령어는 hydrate를 사용하여, 앱을 interative하게 만든다.

RSC는 React Server Component Tree가 렌더된 작은 바이너리 표현이다. 클라이언트에서 React가 브라우저 DOM을 업데이트 하는데 사용됩니다. RSC Payload는 아래의 항목들을 포함한다.

- Server Component가 렌더된 결과
- 클라이어트 컴포넌트가 렌더링될 위치와 해당 자바스크립트 파일에 대한 참조를 위한 자리 Placeholder
- 서버 컴포넌트에서 클라이언트 컴포넌트로 전달된 모든 props

---

React Server Component와 SSR은 다릅니다. 둘 다 "server" 라는 이름을 가지고 서버에서 동작하기 때문에 조금 혼란스러울 수 있다. 하지만 두 개념은 완벽히 다릅니다. RSC를 사용하면 SSR 사용은 필요로하지 않고, 그 반대도 마찬가지 입니다. SSR은 React 트리를 raw html로 렌더링하는 환경을 시뮬레이션합니다. 서버와 클라이언트 컴포넌트를 구분하지 않고 동일한 방식으로 렌더링합니다.

리액트는 기본적으로 클라이언트 컴포넌트에서 렌더링되는데, 그럼 서버컴포넌트가 가지는 이점은 무엇일까

1. 데이터를 직접적으로 가져올 수 있기 때문에, 일반적으로 데이터 소스와 더 밀접하게 배치되어 있으므로 브라우저보다 더 빠르게 데이터를 가져올 수 있다.
2. 서버는 마크다운을 HTML로 렌더링 하는 npm 패키지와 같은 무거운 코드 모듈을 사용할 때 마다 이러한 종속성을 다운로드할 필요가 없으므로 서버에서 저렴하게 사용할 수 있다. => 모든 코드를 자바스크립트 번들로 다운로드 해야 되는 브라우저와 다르게

즉 서버 컴포넌트는 데이터 패칭과 컨텐츠 렌더링에 집중할 수 있고, 클라이언트에서는 인터랙티브에 집중할 수 있다. 해당 결과로는 더 빠른 페이지 로드, 더 작은 자바스크립트 번들사이즈와 더 좋은 유저경험을 제공한다.

zero bundle size에 대한 고민 => RSC payload로 직렬화하여 서버 컴포넌트를 내려주는 것이기 때문에, zero bundle size인 것은 이해했다. 하지만 무거운 라이브러리 같은 것을 사용한다고 가정하면 과연 이게 성능적으로 좋을까에 대한 의문이 있었다. 만약에 클라이언트의 인터넷 속도가 느리고 무거운 라이브러리를 사용한다고 가정하면, server component에서 무거운 라이브러리를 사용한다면 클라이언트 인터넷 속도에 영향없이 결국 서버의 리소스를 사용하는 것이기 때문에, 클라이언트 인터넷 속도에 영향을 받지 않고 좋은 퍼포먼스를 낼 수 있다.

RSC로 나누는 것의 이점은 서버가 더 잘할 수 있는 일을 먼저 처리한 후 나머지 작업을 브라우저에 넘겨서 마무리할 수 있습니다. 이렇게 하면 서버가 처리해야 할 일이 줄어듭니다.

일부 컴포넌트는 서버에서 렌더링하고 일부는 클라이언트에서 렌더링하는 페이지의 React 트리를 생각해 보세요. 서버는 평소처럼 서버 컴포넌트를 "렌더링"하여 React 컴포넌트를 div, p와 같은 네이티브 HTML 요소로 전환하지만 브라우저에서 렌더링해야 하는 "클라이언트 컴포넌트"를 만날 때 마다 올바른 클라이언트와 props로 이 구성을 채우라는 지침으로 placeholder를 출력하는 간단한 전략을 생각해보십시오. 그러면 브라우저는 해당 출력을 가져와 클라이언트 컴포넌트로 구 구멍을 채우면 끝입니다.

### The server-client component divide

서버 컴포넌트는 서버에서 동작하고, 클라이언트 컴포넌트는 클라이언트에서 동작하기 때문에 두 컴포넌트가 할 수 있는 일들에는 제한이 있습니다. 하지만 중요한 점은 클라이언트 컴포넌트는 서버 컴포넌트를 import 할 수 없습니다. 이유는 서버 컴포넌트는 브라우저에서 동작할 수 없고, 브라우저에서 작동하지 않는 코드가 있을 수도 있습니다.

### Life of an RSC render

1. Server Receives a request to render
서버가 렌더링의 일부를 수행해야 되기 때문에, RSC를 사용하는 페이지의 수명은 항상 서버에서 시작되며, 일부 API 호출에 대한 응답으로 React 컴포넌트를 렌더링합니다. Root컴포넌트는 항상 서버 컴포넌트이며, 다른 서버 또는 클라이언트 컴포넌트를 렌더할 수 있습니다. 서버는 요청에 전달된 정보를 바탕으로 어떤 서버 컴포넌트와 어떤 props를 사용할지 파악합니다.
2. Server serializes root component element to JSON
해당 단계에 최종 목표는 초기 루트 서버 컴포넌트를 기본 HTML 태그와 클라이언트 컴포넌트 "placeholder"형태의 트리로 렌더링하는 것입니다.
리액트 엘리먼트가 직렬화 되는 것은 다음과 같다.
    - 기본적인 HTML tag 들이라면, 이것은 바로 직렬화를 할 수 있다.
    - 서버 컴포넌트라면, 해당 프로퍼티를 사용하여 서버 컴포넌트 함수를 호출하고 결과를 직렬화 한다. 여기에 최종 목표는 서버 컴포넌트를 HTML를 변경하는 것입니다.
    - 클라이언트 컴포넌트라면, 이것은 바로 직렬화 할 수 있다. type field는 component function을 가르키는게 아니라 항상 module reference object를 가르킨다.
    직접 컴포넌트를 직렬화 하는게 아니라 module reference object를 가져오게 되는데, 리액트 팀에서 퍼블리싱한 react-server-dom-webpack 번들러를 이용합니다. 서버 컴포넌트가 클라이언트 컴포넌트 import를 만나게 되면, 직접 해당 컴포넌트를 가져오는 것 대신에, 파일 이름과 export 하는 이름을 포함하는 module reference object를 가져온다. 이게 placeholder방식이다.
3. Brower reconstructs the React tree
브라우저에서 서버로부터 JSON형태를 받은 후에 브라우저에서는 바로 리액트를 렌더하기 위해 리액트 트리를 재구성합니다. module reference type을 만나면 실제 클라이언트 컴포넌트로 재배치합니다. 그리고 리액트를 렌더하고, DOM에 이 트리를 보내줍니다.

참고: https://www.plasmic.app/blog/how-react-server-components-work#what-are-react-server-components
